import functools
import logging
import time

logger = logging.getLogger('schedule')

def now():
    return int(time.time())

class CancelJob(object):
    pass

class Scheduler(object):

    def __init__(self):
        self.jobs = []

    def run_pending(self):
        """Run all jobs that are scheduled to run now.

        Missed intervals are not backfilled by design; only the next due
        occurrence is executed for each job.
        """
        runnable_jobs = (job for job in self.jobs if job.should_run)
        for job in sorted(runnable_jobs):
            self._run_job(job)

    def run_all(self, delay_seconds=0):
        """Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time."""
        logger.info('Running *all* %i jobs with %is delay in between',
                    len(self.jobs), delay_seconds)
        for job in self.jobs:
            self._run_job(job)
            time.sleep(delay_seconds)

    def clear(self):
        """Deletes all scheduled jobs."""
        del self.jobs[:]

    def cancel_job(self, job):
        """Delete a scheduled job."""
        try:
            self.jobs.remove(job)
        except ValueError:
            pass

    def every(self, interval=1):
        """Schedule a new periodic job."""
        job = Job(interval)
        self.jobs.append(job)
        return job

    def _run_job(self, job):
        # Ensure a failing job doesn't break the scheduler loop
        ret = job.run()
        if isinstance(ret, CancelJob) or ret is CancelJob:
            self.cancel_job(job)

    @property
    def next_run(self):
        """Datetime when the next job should run."""
        if not self.jobs:
            return None
        return min(self.jobs).next_run

    @property
    def idle_seconds(self):
        """Number of seconds until `next_run`."""
        nr = self.next_run
        if nr is None:
            return None
        delta = nr - now()
        return 0 if delta < 0 else delta


class Job(object):
    """A periodic job as used by `Scheduler`."""

    def __init__(self, interval):
        self.interval = interval  # pause interval * unit between runs
        self.job_func = None  # the job job_func to run
        self.unit = None  # time units, e.g. 'minutes', 'hours', ...
        self.at_time = None  # optional time at which this job runs
        self.last_run = None  # time of the last run
        self.next_run = None  # time of the next run
        self.period = None  # timedelta between runs, only valid for
        self.start_day = None  # Specific day of the week to start on

    def __repr__(self):
        parts = ["Job("]
        if self.interval is not None and self.unit:
            parts.append("every %s %s" % (self.interval, self.unit))
        if self.at_time is not None:
            # at_time may be [h, m] or [h, m, s]
            h = self.at_time[0]
            m = self.at_time[1]
            s = self.at_time[2] if len(self.at_time) > 2 else 0
            parts.append(" at %02d:%02d:%02d" % (h, m, s))
        if self.start_day is not None:
            parts.append(" on %s" % self.start_day)
        if self.next_run is not None:
            parts.append(" next_run=%d" % self.next_run)
        parts.append(")")
        return ''.join(parts)

    def __lt__(self, other):
        """PeriodicJobs are sortable based on the scheduled time
        they run next."""
        return self.next_run < other.next_run

    @property
    def second(self):
        assert self.interval == 1
        return self.seconds

    @property
    def seconds(self):
        self.unit = 'seconds'
        return self

    @property
    def minute(self):
        assert self.interval == 1
        return self.minutes

    @property
    def minutes(self):
        self.unit = 'minutes'
        return self

    @property
    def hour(self):
        assert self.interval == 1
        return self.hours

    @property
    def hours(self):
        self.unit = 'hours'
        return self

    @property
    def day(self):
        assert self.interval == 1
        return self.days

    @property
    def days(self):
        self.unit = 'days'
        return self

    @property
    def week(self):
        assert self.interval == 1
        return self.weeks

    @property
    def monday(self):
        assert self.interval == 1
        self.start_day = 'monday'
        return self.weeks

    @property
    def tuesday(self):
        assert self.interval == 1
        self.start_day = 'tuesday'
        return self.weeks

    @property
    def wednesday(self):
        assert self.interval == 1
        self.start_day = 'wednesday'
        return self.weeks

    @property
    def thursday(self):
        assert self.interval == 1
        self.start_day = 'thursday'
        return self.weeks

    @property
    def friday(self):
        assert self.interval == 1
        self.start_day = 'friday'
        return self.weeks

    @property
    def saturday(self):
        assert self.interval == 1
        self.start_day = 'saturday'
        return self.weeks

    @property
    def sunday(self):
        assert self.interval == 1
        self.start_day = 'sunday'
        return self.weeks

    @property
    def weeks(self):
        self.unit = 'weeks'
        return self

    def at(self, time_str):
        """Schedule the job at a specific time of day/hour.

        Valid formats:
        - "HH:MM" or "HH:MM:SS" for daily/weekly jobs
        - ":MM" or ":MM:SS" for hourly jobs (minutes/seconds past the hour)
        """
        assert self.unit in ('days', 'hours') or self.start_day
        ts = time_str.strip()
        parts = ts.split(':')
        if len(parts) < 2:
            raise ValueError('time string must be HH:MM[:SS] or :MM[:SS]')
        # Parse seconds if provided
        sec = int(parts[2]) if len(parts) > 2 and parts[2] != '' else 0
        # Hours may be blank when unit == 'hours'
        if self.unit == 'hours' and (parts[0] == '' or parts[0] is None):
            hour = 0
        else:
            hour = int(parts[0])
        minute = int(parts[1])

        if self.unit == 'days' or self.start_day:
            assert 0 <= hour <= 23
        elif self.unit == 'hours':
            hour = 0  # force hour to the top of the hour boundary

        assert 0 <= minute <= 59
        assert 0 <= sec <= 59
        self.at_time = [hour, minute, sec]
        return self

    def do(self, job_func, *args, **kwargs):
        """Specifies the job_func that should be called every time the
        job runs.

        Any additional arguments are passed on to job_func when
        the job runs.
        """
        self.job_func = functools.partial(job_func, *args, **kwargs)
        try:
            functools.update_wrapper(self.job_func, job_func)
        except AttributeError:
            # job_funcs already wrapped by functools.partial won't have
            # __name__, __module__ or __doc__ and the update_wrapper()
            # call will fail.
            pass
        self._schedule_next_run()
        return self

    @property
    def should_run(self):
        """True if the job should be run now."""
        return now() >= self.next_run

    def run(self):
        """Run the job and immediately reschedule it.

        Any exception raised by the job function is caught and logged; the
        job is still rescheduled for its next occurrence.
        """
        logger.info('Running job %s', self)
        ret = None
        try:
            ret = self.job_func()
        except Exception as e:  # noqa: E722 (broad for embedded)
            try:
                logger.exception('Job %s raised an exception: %s', self, e)
            except Exception:
                # Ensure logging issues never break scheduling
                pass
        self.last_run = now()
        self._schedule_next_run()
        return ret

    def _schedule_next_run(self):
        """Compute the instant when this job should run next."""
        assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')

        # Compute base period in seconds
        f = 1
        if self.unit == 'minutes':
            f = 60
        elif self.unit == 'hours':
            f = 60 * 60
        elif self.unit == 'days':
            f = 60 * 60 * 24
        elif self.unit == 'weeks':
            f = 60 * 60 * 24 * 7
        self.period = f * self.interval

        # Fast path: simple periodic jobs without specific time-of-day or weekday
        if self.at_time is None and self.start_day is None:
            if self.next_run is None:
                self.next_run = now() + self.period
            else:
                current = now()
                if current >= self.next_run:
                    steps = (current - self.next_run) // self.period + 1
                    self.next_run += steps * self.period
                # else: keep the scheduled next_run as-is
            return

        # Time-of-day and/or weekday anchored scheduling
        base = now()
        next_run = base

        if self.at_time is not None:
            tm = list(time.localtime(base))
            h = self.at_time[0]
            m = self.at_time[1]
            s = self.at_time[2] if len(self.at_time) > 2 else 0

            # Determine if the target time has already passed today
            passed_today = (self.period > 60 * 60 * 24)
            if self.unit == 'days' or self.start_day:
                passed_today = passed_today or (
                    (tm[3] > h) or (tm[3] == h and (tm[4] > m or (tm[4] == m and tm[5] >= s)))
                )
            elif self.unit == 'hours':
                passed_today = passed_today or (
                    (tm[4] > m) or (tm[4] == m and tm[5] >= s)
                )

            # Only force hour for days/weeks, not for hours
            if self.unit in ('days', 'weeks') or self.start_day:
                tm[3] = h
            tm[4] = m
            tm[5] = s
            next_run = time.mktime(tuple(tm))

            # If not passed yet today, allow today; otherwise it rolls over below
            if not passed_today:
                next_run -= self.period

        # Move to the next period from the computed anchor
        next_run += self.period

        if self.start_day is not None:
            # Align to the requested weekday
            assert self.unit == 'weeks'
            weekdays = (
                'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'
            )
            wd = time.localtime(next_run)[6]
            assert self.start_day in weekdays
            weekday = weekdays.index(self.start_day)
            days_ahead = weekday - wd
            if days_ahead <= 0:
                days_ahead += 7
            next_run += days_ahead * 60 * 60 * 24 - self.period

        if self.start_day is not None and self.at_time is not None:
            # Ensure we don't skip the intended time by overshooting a whole week
            if (next_run - now()) >= 7 * 60 * 60 * 24:
                next_run -= self.period

        self.next_run = next_run

# The following methods are shortcuts for not having to
# create a Scheduler instance:

default_scheduler = Scheduler()
jobs = default_scheduler.jobs  # todo: should this be a copy, e.g. jobs()?


def every(interval=1):
    """Schedule a new periodic job."""
    return default_scheduler.every(interval)


def run_pending():
    """Run all jobs that are scheduled to run.

    Please note that it is *intended behavior that run_pending()
    does not run missed jobs*. For example, if you've registered a job
    that should run every minute and you only call run_pending()
    in one hour increments then your job won't be run 60 times in
    between but only once.
    """
    default_scheduler.run_pending()


def run_all(delay_seconds=0):
    """Run all jobs regardless if they are scheduled to run or not.

    A delay of `delay` seconds is added between each job. This can help
    to distribute the system load generated by the jobs more evenly over
    time."""
    default_scheduler.run_all(delay_seconds=delay_seconds)


def clear():
    """Deletes all scheduled jobs."""
    default_scheduler.clear()


def cancel_job(job):
    """Delete a scheduled job."""
    default_scheduler.cancel_job(job)


def next_run():
    """Datetime when the next job should run."""
    return default_scheduler.next_run


def idle_seconds():
    """Number of seconds until `next_run`."""
    return default_scheduler.idle_seconds
