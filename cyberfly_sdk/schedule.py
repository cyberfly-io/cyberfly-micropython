"""
MicroPython-compatible job scheduling library.

This module provides a simple way to schedule periodic jobs with various intervals
(seconds, minutes, hours, days, weeks) and specific times of day.

Example:
    import schedule
    
    def my_job():
        print("Job executed!")
    
    # Schedule job every 10 seconds
    schedule.every(10).seconds.do(my_job)
    
    # Schedule job every day at 10:30
    schedule.every().day.at("10:30").do(my_job)
    
    # Run pending jobs in main loop
    while True:
        schedule.run_pending()
        time.sleep(1)
"""

import functools
import time

# Try to import logging, fall back to simple print-based logging
try:
    import logging
    logger = logging.getLogger('schedule')
except ImportError:
    # Simple logger fallback for MicroPython
    class SimpleLogger:
        def info(self, msg, *args):
            try:
                print("[INFO]", msg % args if args else msg)
            except:
                print("[INFO]", msg)
        
        def exception(self, msg, *args):
            try:
                print("[ERROR]", msg % args if args else msg)
            except:
                print("[ERROR]", msg)
    
    logger = SimpleLogger()

def now():
    """Return current Unix timestamp as integer."""
    try:
        import cntptime
        return int(cntptime.get_rtc_time())
    except:
        return int(time.time())

class CancelJob(object):
    """Sentinel class to signal that a job should be canceled.
    
    Return this from a job function to automatically remove it from the scheduler.
    
    Example:
        def my_job():
            if condition:
                return schedule.CancelJob
    """
    pass

class Scheduler(object):
    """Job scheduler managing multiple periodic jobs.
    
    Attributes:
        jobs: List of scheduled Job instances
    """

    def __init__(self):
        """Initialize a new Scheduler with an empty job list."""
        self.jobs = []

    def run_pending(self):
        """Run all jobs that are scheduled to run now.

        Missed intervals are not backfilled by design; only the next due
        occurrence is executed for each job.
        """
        runnable_jobs = (job for job in self.jobs if job.should_run)
        for job in sorted(runnable_jobs):
            self._run_job(job)

    def run_all(self, delay_seconds=0):
        """Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time."""
        logger.info('Running *all* %i jobs with %is delay in between',
                    len(self.jobs), delay_seconds)
        for job in self.jobs:
            self._run_job(job)
            time.sleep(delay_seconds)

    def clear(self):
        """Deletes all scheduled jobs."""
        del self.jobs[:]

    def cancel_job(self, job):
        """Delete a scheduled job.
        
        Args:
            job: The Job instance to remove
            
        Returns:
            bool: True if job was found and removed, False otherwise
        """
        try:
            self.jobs.remove(job)
            return True
        except ValueError:
            return False

    def every(self, interval=1):
        """Schedule a new periodic job.
        
        Args:
            interval: Number of time units between job executions (default: 1)
            
        Returns:
            Job: A new Job instance for method chaining
            
        Example:
            schedule.every(5).minutes.do(my_job)
        """
        job = Job(interval, self)
        self.jobs.append(job)
        return job

    def _run_job(self, job):
        """Execute a job and handle cancellation.
        
        Args:
            job: The Job instance to run
            
        Note:
            Failing jobs don't break the scheduler loop. Exceptions are caught and logged.
        """
        ret = job.run()
        if isinstance(ret, CancelJob) or ret is CancelJob:
            self.cancel_job(job)

    @property
    def next_run(self):
        """Get the timestamp when the next job should run.
        
        Returns:
            int or None: Unix timestamp of next scheduled job, or None if no jobs
        """
        if not self.jobs:
            return None
        return min(self.jobs).next_run

    @property
    def idle_seconds(self):
        """Get the number of seconds until the next job should run.
        
        Returns:
            int or None: Seconds until next job, 0 if overdue, or None if no jobs
        """
        nr = self.next_run
        if nr is None:
            return None
        delta = int(nr - now())
        return 0 if delta < 0 else delta


class Job(object):
    """A periodic job as used by Scheduler.
    
    Attributes:
        interval: Number of time units between executions
        job_func: The function to execute
        unit: Time unit ('seconds', 'minutes', 'hours', 'days', 'weeks')
        at_time: Optional [hour, minute, second] for scheduled execution
        last_run: Unix timestamp of last execution
        next_run: Unix timestamp of next scheduled execution
        period: Interval in seconds between executions
        start_day: Specific weekday for weekly jobs
        scheduler: Reference to parent Scheduler
    """

    def __init__(self, interval, scheduler=None):
        """Initialize a new Job.
        
        Args:
            interval: Number of time units between executions
            scheduler: Optional reference to parent Scheduler
        """
        self.interval = interval
        self.job_func = None
        self.unit = None
        self.at_time = None
        self.last_run = None
        self.next_run = None
        self.period = None
        self.start_day = None
        self.scheduler = scheduler

    def __repr__(self):
        """Return string representation of the job."""
        parts = ["Job("]
        if self.interval is not None and self.unit:
            parts.append("every %s %s" % (self.interval, self.unit))
        if self.at_time is not None:
            # at_time may be [h, m] or [h, m, s]
            h = self.at_time[0]
            m = self.at_time[1]
            s = self.at_time[2] if len(self.at_time) > 2 else 0
            parts.append(" at %02d:%02d:%02d" % (h, m, s))
        if self.start_day is not None:
            parts.append(" on %s" % self.start_day)
        if self.next_run is not None:
            parts.append(" next_run=%d" % int(self.next_run))
        parts.append(")")
        return ''.join(parts)

    def __lt__(self, other):
        """Compare jobs based on next_run time for sorting.
        
        Args:
            other: Another Job instance
            
        Returns:
            bool: True if this job runs before the other
        """
        return self.next_run < other.next_run

    @property
    def second(self):
        """Schedule job every second (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Use seconds (not second) for interval > 1')
        return self.seconds

    @property
    def seconds(self):
        """Schedule job with second interval."""
        self.unit = 'seconds'
        return self

    @property
    def minute(self):
        """Schedule job every minute (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Use minutes (not minute) for interval > 1')
        return self.minutes

    @property
    def minutes(self):
        """Schedule job with minute interval."""
        self.unit = 'minutes'
        return self

    @property
    def hour(self):
        """Schedule job every hour (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Use hours (not hour) for interval > 1')
        return self.hours

    @property
    def hours(self):
        """Schedule job with hour interval."""
        self.unit = 'hours'
        return self

    @property
    def day(self):
        """Schedule job every day (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Use days (not day) for interval > 1')
        return self.days

    @property
    def days(self):
        """Schedule job with day interval."""
        self.unit = 'days'
        return self

    @property
    def week(self):
        """Schedule job every week (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Use weeks (not week) for interval > 1')
        return self.weeks

    @property
    def monday(self):
        """Schedule job every Monday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'monday'
        return self.weeks

    @property
    def tuesday(self):
        """Schedule job every Tuesday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'tuesday'
        return self.weeks

    @property
    def wednesday(self):
        """Schedule job every Wednesday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'wednesday'
        return self.weeks

    @property
    def thursday(self):
        """Schedule job every Thursday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'thursday'
        return self.weeks

    @property
    def friday(self):
        """Schedule job every Friday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'friday'
        return self.weeks

    @property
    def saturday(self):
        """Schedule job every Saturday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'saturday'
        return self.weeks

    @property
    def sunday(self):
        """Schedule job every Sunday (interval must be 1)."""
        if self.interval != 1:
            raise ValueError('Weekday scheduling requires interval of 1')
        self.start_day = 'sunday'
        return self.weeks

    @property
    def weeks(self):
        """Schedule job with week interval."""
        self.unit = 'weeks'
        return self

    def at(self, time_str):
        """Schedule the job at a specific time of day/hour.

        Args:
            time_str: Time string in one of these formats:
                - "HH:MM" or "HH:MM:SS" for daily/weekly jobs
                - ":MM" or ":MM:SS" for hourly jobs (minutes/seconds past the hour)
                
        Returns:
            Job: Self for method chaining
            
        Raises:
            ValueError: If time format is invalid or unit is incompatible
            
        Example:
            schedule.every().day.at("10:30").do(job)
            schedule.every().hour.at(":15").do(job)  # 15 minutes past each hour
        """
        if not (self.unit in ('days', 'hours') or self.start_day):
            raise ValueError('at() can only be used with days, hours, or weekday scheduling')
        ts = time_str.strip()
        parts = ts.split(':')
        if len(parts) < 2:
            raise ValueError('time string must be HH:MM[:SS] or :MM[:SS]')
        # Parse seconds if provided
        sec = int(parts[2]) if len(parts) > 2 and parts[2] != '' else 0
        # Hours may be blank when unit == 'hours'
        if self.unit == 'hours' and (parts[0] == '' or parts[0] is None):
            hour = 0
        else:
            hour = int(parts[0])
        minute = int(parts[1])

        if self.unit == 'days' or self.start_day:
            if not (0 <= hour <= 23):
                raise ValueError('Hour must be between 0-23')
        elif self.unit == 'hours':
            hour = 0  # force hour to the top of the hour boundary

        if not (0 <= minute <= 59):
            raise ValueError('Minute must be between 0-59')
        if not (0 <= sec <= 59):
            raise ValueError('Second must be between 0-59')
        self.at_time = [hour, minute, sec]
        return self

    def do(self, job_func, *args, **kwargs):
        """Specify the function to execute when the job runs.

        Args:
            job_func: Callable to execute
            *args: Positional arguments to pass to job_func
            **kwargs: Keyword arguments to pass to job_func
            
        Returns:
            Job: Self for potential further operations
            
        Example:
            def my_job(name):
                print(f"Hello {name}")
            
            schedule.every(10).seconds.do(my_job, "World")
        """
        self.job_func = functools.partial(job_func, *args, **kwargs)
        try:
            functools.update_wrapper(self.job_func, job_func)
        except AttributeError:
            # job_funcs already wrapped by functools.partial won't have
            # __name__, __module__ or __doc__ and the update_wrapper()
            # call will fail.
            pass
        self._schedule_next_run()
        return self

    @property
    def should_run(self):
        """Check if the job should run now.
        
        Returns:
            bool: True if current time >= scheduled next_run time
        """
        return now() >= self.next_run

    def run(self):
        """Execute the job function and reschedule for next run.

        The job is always rescheduled, even if an exception occurs.
        Exceptions are caught, logged, and don't break the scheduler.
        
        Returns:
            Any: The return value of the job function, or None if it raised an exception
        """
        logger.info('Running job %s', self)
        ret = None
        try:
            ret = self.job_func()
        except Exception as e:  # noqa: E722 (broad for embedded)
            try:
                logger.exception('Job %s raised an exception: %s', self, e)
            except Exception:
                # Ensure logging issues never break scheduling
                pass
        self.last_run = now()
        self._schedule_next_run()
        return ret

    def _schedule_next_run(self):
        """Calculate and set the next_run timestamp for this job.
        
        Handles various scheduling modes:
        - Simple periodic: run every N units from now
        - Time-of-day: run at specific time each period
        - Weekday: run on specific day of week
        
        Raises:
            ValueError: If unit is not set or invalid
        """
        if not self.unit or self.unit not in ('seconds', 'minutes', 'hours', 'days', 'weeks'):
            raise ValueError(f'Invalid time unit: {self.unit}')

        # Compute base period in seconds
        f = 1
        if self.unit == 'minutes':
            f = 60
        elif self.unit == 'hours':
            f = 60 * 60
        elif self.unit == 'days':
            f = 60 * 60 * 24
        elif self.unit == 'weeks':
            f = 60 * 60 * 24 * 7
        self.period = f * self.interval

        # Fast path: simple periodic jobs without specific time-of-day or weekday
        if self.at_time is None and self.start_day is None:
            if self.next_run is None:
                self.next_run = now() + self.period
            else:
                current = now()
                if current >= self.next_run:
                    steps = (current - self.next_run) // self.period + 1
                    self.next_run += steps * self.period
                # else: keep the scheduled next_run as-is
            return

        # Time-of-day and/or weekday anchored scheduling
        base = now()
        next_run = base

        if self.at_time is not None:
            try:
                tm = list(time.localtime(base))
            except (OSError, OverflowError):
                # Handle potential timestamp overflow in MicroPython
                base = now()
                tm = list(time.localtime(base))
            h = self.at_time[0]
            m = self.at_time[1]
            s = self.at_time[2] if len(self.at_time) > 2 else 0

            # Determine if the target time has already passed today
            passed_today = (self.period > 60 * 60 * 24)
            if self.unit == 'days' or self.start_day:
                passed_today = passed_today or (
                    (tm[3] > h) or (tm[3] == h and (tm[4] > m or (tm[4] == m and tm[5] >= s)))
                )
            elif self.unit == 'hours':
                passed_today = passed_today or (
                    (tm[4] > m) or (tm[4] == m and tm[5] >= s)
                )

            # Only force hour for days/weeks, not for hours
            if self.unit in ('days', 'weeks') or self.start_day:
                tm[3] = h
            tm[4] = m
            tm[5] = s
            try:
                next_run = time.mktime(tuple(tm))
            except (OSError, OverflowError):
                # Fallback for MicroPython platforms without mktime
                # Calculate timestamp manually
                next_run = base + (h - tm[3]) * 3600 + (m - tm[4]) * 60 + (s - tm[5])

            # If not passed yet today, allow today; otherwise it rolls over below
            if not passed_today:
                next_run -= self.period

        # Move to the next period from the computed anchor
        next_run += self.period

        if self.start_day is not None:
            # Align to the requested weekday
            if self.unit != 'weeks':
                raise ValueError('start_day requires weeks unit')
            weekdays = (
                'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'
            )
            wd = time.localtime(int(next_run))[6]
            if self.start_day not in weekdays:
                raise ValueError(f'Invalid weekday: {self.start_day}')
            weekday = weekdays.index(self.start_day)
            days_ahead = weekday - wd
            if days_ahead <= 0:
                days_ahead += 7
            next_run += days_ahead * 60 * 60 * 24 - self.period

        if self.start_day is not None and self.at_time is not None:
            # Ensure we don't skip the intended time by overshooting a whole week
            if (next_run - now()) >= 7 * 60 * 60 * 24:
                next_run -= self.period

        self.next_run = next_run

# ============================================================================
# Module-level convenience functions for default scheduler
# ============================================================================

default_scheduler = Scheduler()

def jobs():
    """Get the list of scheduled jobs in the default scheduler.
    
    Returns:
        list: List of Job instances
    """
    return default_scheduler.jobs[:]


def every(interval=1):
    """Schedule a new periodic job using the default scheduler.
    
    Args:
        interval: Number of time units between executions (default: 1)
        
    Returns:
        Job: A new Job instance for method chaining
        
    Example:
        schedule.every(10).seconds.do(my_job)
        schedule.every().day.at("10:30").do(my_job)
    """
    return default_scheduler.every(interval)


def run_pending():
    """Run all jobs scheduled to run now in the default scheduler.

    Note:
        By design, missed intervals are not backfilled. Only the next
        due occurrence is executed for each job. For example, if a job
        should run every minute but run_pending() is only called hourly,
        the job runs once (not 60 times).
        
    Example:
        while True:
            schedule.run_pending()
            time.sleep(1)
    """
    default_scheduler.run_pending()


def run_all(delay_seconds=0):
    """Run all jobs immediately, regardless of schedule.

    Args:
        delay_seconds: Number of seconds to wait between each job execution
                      to help distribute system load (default: 0)
                      
    Example:
        schedule.run_all()  # Run all jobs now
        schedule.run_all(delay_seconds=2)  # Run with 2s between each
    """
    default_scheduler.run_all(delay_seconds=delay_seconds)


def clear():
    """Delete all scheduled jobs from the default scheduler.
    
    Example:
        schedule.clear()  # Remove all jobs
    """
    default_scheduler.clear()


def cancel_job(job):
    """Remove a specific job from the default scheduler.
    
    Args:
        job: The Job instance to remove
        
    Returns:
        bool: True if job was found and removed, False otherwise
        
    Example:
        job = schedule.every(10).seconds.do(my_function)
        schedule.cancel_job(job)
    """
    return default_scheduler.cancel_job(job)


def next_run():
    """Get the timestamp when the next job should run.
    
    Returns:
        int or None: Unix timestamp of next scheduled job, or None if no jobs
    """
    return default_scheduler.next_run


def idle_seconds():
    """Get the number of seconds until the next job should run.
    
    Returns:
        int or None: Seconds until next job, 0 if overdue, or None if no jobs
        
    Example:
        sleep_time = schedule.idle_seconds()
        if sleep_time:
            time.sleep(min(sleep_time, 60))  # Sleep up to 60 seconds
    """
    return default_scheduler.idle_seconds
